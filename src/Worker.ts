import * as path from 'path';
import { spawn, ChildProcess } from 'child_process';
import { SctpCapabilities } from 'mediasoup-client/src/types'
import Logger from './Logger';
import { EnhancedEventEmitter } from './EnhancedEventEmitter';
import Channel from './Channel';

export type WorkerLogLevel = 'debug' | 'warn' | 'error' | 'none';

export type WorkerState = 'connecting' | 'open' | 'closed'

export interface WorkerSettings
{
	/**
	 * Logging level for logs generated by the media worker subprocesses (check
	 * the Debugging documentation). Valid values are 'debug', 'warn', 'error' and
	 * 'none'. Default 'error'.
	 */
	logLevel?: WorkerLogLevel;

	/**
	 * RTCConfiguration object.
	 */
	rtcConfiguration?: RTCConfiguration;
}

export interface SendOptions
{
	kind: 'audio' | 'video';
	sourceType: 'device' | 'file' | 'url';
	sourceValue?: string;
}

type WorkerSendResult =
{
	trackId: string;
};

// TODO.
const workerBin = '/usr/local/bin/python3';

const logger = new Logger('Worker');

export class Worker extends EnhancedEventEmitter
{
	// mediasoup-worker child process.
	private _child?: ChildProcess;

	// Logger for stdout and stderr logs from the worker process.
	private readonly _workerLogger: Logger;

	// Worker process PID.
	private readonly _pid: number;

	// Channel instance.
	private readonly _channel: Channel;

	// State.
	private _state: WorkerState = 'closed';

	// Observer instance.
	private readonly _observer = new EnhancedEventEmitter();

	/**
	 * @private
	 * @emits open
	 * @emits failure (Error)
	 * @emits error (Error)
	 */
	constructor(
		{
			logLevel,
			rtcConfiguration
		}: WorkerSettings)
	{
		super();

		logger.debug('constructor()');

		const spawnBin = workerBin;
		const spawnArgs: string[] = [];

		spawnArgs.push('-u'); // Unbuffered stdio.

		spawnArgs.push(path.join(__dirname, '..', 'worker', 'worker.py'));

		if (logLevel)
			spawnArgs.push(`--logLevel=${logLevel}`);

		if (rtcConfiguration)
			spawnArgs.push(`--rtcConfiguration=${JSON.stringify(rtcConfiguration)}`);

		logger.debug(
			'spawning worker process: %s %s', spawnBin, spawnArgs.join(' '));

		this._state = 'connecting';
		this._child = spawn(
			// command
			spawnBin,
			// args
			spawnArgs,
			// options
			{
				env :
				{
					MEDIASOUP_VERSION : '__MEDIASOUP_VERSION__'
				},

				detached : false,

				// fd 0 (stdin)   : Just ignore it.
				// fd 1 (stdout)  : Pipe it for 3rd libraries that log their own stuff.
				// fd 2 (stderr)  : Same as stdout.
				// fd 3 (channel) : Producer Channel fd.
				// fd 4 (channel) : Consumer Channel fd.
				stdio : [ 'ignore', 'pipe', 'pipe', 'pipe', 'pipe' ]
			});

		this._workerLogger = new Logger(`worker[pid:${this._child.pid}]`);

		this._pid = this._child.pid;

		this._channel = new Channel(
			{
				sendSocket : this._child.stdio[3],
				recvSocket : this._child.stdio[4],
				pid        : this._pid
			});

		let spawnDone = false;

		// Listen for iceconnectionstatechange event.
		this._channel.on('iceconnectionstatechange', (iceConnectionState: string) =>
		{
			this.emit('iceconnectionstatechange', iceConnectionState);
		});

		// Listen for 'open' notification.
		this._channel.once(String(this._pid), (event: string) =>
		{
			if (!spawnDone && event === 'running')
			{
				spawnDone = true;

				logger.debug('worker process running [pid:%s]', this._pid);

				this._state = 'open';
				this.emit('open');
			}
		});

		this._child.on('exit', (code, signal) =>
		{
			this._child = undefined;
			this.close();

			if (!spawnDone)
			{
				spawnDone = true;

				if (code === 42)
				{
					logger.error(
						'worker process failed due to wrong settings [pid:%s]', this._pid);

					this.emit('failure', new TypeError('wrong settings'));
				}
				else
				{
					logger.error(
						'worker process failed unexpectedly [pid:%s, code:%s, signal:%s]',
						this._pid, code, signal);

					this._state = 'closed'
					this.emit(
						'failure',
						new Error(`[pid:${this._pid}, code:${code}, signal:${signal}]`));
				}
			}
			else
			{
				logger.error(
					'worker process died unexpectedly [pid:%s, code:%s, signal:%s]',
					this._pid, code, signal);

				this._state = 'closed';
				this.safeEmit(
					'error',
					new Error(`[pid:${this._pid}, code:${code}, signal:${signal}]`));
			}
		});

		this._child.on('error', (error) =>
		{
			this._child = undefined;
			this.close();

			if (!spawnDone)
			{
				spawnDone = true;

				logger.error(
					'worker process failed [pid:%s]: %s', this._pid, error.message);

				this._state = 'closed';
				this.emit('failure', error);
			}
			else
			{
				logger.error(
					'worker process error [pid:%s]: %s', this._pid, error.message);

				this._state = 'closed';
				this.safeEmit('error', error);
			}
		});

		// Be ready for 3rd party worker libraries logging to stdout.
		this._child.stdout.on('data', (buffer) =>
		{
			for (const line of buffer.toString('utf8').split('\n'))
			{
				if (line)
					this._workerLogger.debug(`(stdout) ${line}`);
			}
		});

		// In case of a worker bug, mediasoup will log to stderr.
		this._child.stderr.on('data', (buffer) =>
		{
			for (const line of buffer.toString('utf8').split('\n'))
			{
				if (line)
					this._workerLogger.error(`(stderr) ${line}`);
			}
		});
	}

	/**
	 * Worker process identifier (PID).
	 */
	get pid(): number
	{
		return this._pid;
	}

	/**
	 * Observer.
	 *
	 * @emits close
	 */
	get observer(): EnhancedEventEmitter
	{
		return this._observer;
	}

	getState(): WorkerState
	{
		return this._state;
	}

	async getRtpCapabilities(): Promise<string>
	{
		logger.debug('getRtpCapabilities()');

		return await this._channel.request('getRtpCapabilities');
	}

	async getSctpCapabilities(): Promise<SctpCapabilities>
	{
		logger.debug('getSctpCapabilities()');

		return {
			numStreams: { OS: 0, MIS: 0 }
		};
	}

	async getLocalDescription(): Promise<RTCSessionDescription>
	{
		logger.debug('getLocalDescription()');

		return await this._channel.request('getLocalDescription');
	}

	async addTrack(sendOptions: SendOptions): Promise<WorkerSendResult>
	{
		logger.debug(`send() | [sendOptions:${JSON.stringify(sendOptions)}]`);

		return await this._channel.request('addTrack', sendOptions);
	}

	async removeTrack(trackId: string): Promise<void>
	{
		logger.debug(`removeTrack() | [trackId:${trackId}]`);

		return await this._channel.request('removeTrack', { trackId });
	}

	async setLocalDescription(desc: RTCSessionDescription): Promise<void>
	{
		logger.debug('setLocalDescription()');

		return await this._channel.request('setLocalDescription', desc);
	}

	async setRemoteDescription(desc: RTCSessionDescription): Promise<void>
	{
		logger.debug('setRemoteDescription()');

		return await this._channel.request('setRemoteDescription', desc);
	}

	async createOffer(
		// eslint-disable-next-line @typescript-eslint/no-unused-vars
		{ iceRestart }:
		{
			iceRestart: boolean;
		}): Promise<RTCSessionDescription>
	{
		logger.debug('setRemoteDescription()');

		return await this._channel.request('createOffer');
	}

	async createAnswer(): Promise<RTCSessionDescription>
	{
		logger.debug('createAnswer()');

		return await this._channel.request('createAnswer');
	}

	async getMid(trackId: string): Promise<string | undefined>
	{
		logger.debug('getMid()');

		try
		{
			const mid = await this._channel.request('getMid', { trackId });

			return mid;
		}
		catch (error)
		{
			return undefined;
		}
	}

	async enableTrack(trackId: string): Promise<void>
	{
		logger.debug('enableTrack()');

		await this._channel.notify('enableTrack', { trackId });
	}

	async disableTrack(trackId: string): Promise<void>
	{
		logger.debug('disableTrack()');

		await this._channel.notify('disableTrack', { trackId });
	}

	async getTransportStats(): Promise<RTCStatsReport>
	{
		logger.debug('getTransportStats()');

		return await this._channel.request('getTransportStats');
	}

	async getSenderStats(trackId: string): Promise<RTCStatsReport>
	{
		logger.debug('getSenderStats()');

		return await this._channel.request('getSenderStats', { trackId });
	}

	async getReceiverStats(trackId: string): Promise<RTCStatsReport>
	{
		logger.debug('getReceiverStats()');

		return await this._channel.request('getReceiverStats', { trackId });
	}

	/**
	 * Close the Worker.
	 */
	close(): void
	{
		if (this._state === 'closed')
			return;

		logger.debug('close()');

		this._state = 'closed';

		// Kill the worker process.
		if (this._child)
		{
			// Remove event listeners but leave a fake 'error' hander to avoid
			// propagation.
			this._child.removeAllListeners('exit');
			this._child.removeAllListeners('error');
			// eslint-disable-next-line @typescript-eslint/no-empty-function
			this._child.on('error', () => {});
			this._child.kill('SIGTERM');
			this._child = undefined;
		}

		// Close the Channel instance.
		this._channel.close();

		// Emit observer event.
		this._observer.safeEmit('close');
	}

	/**
	 * Dump Worker.
	 */
	async dump(): Promise<any>
	{
		logger.debug('dump()');

		// TODO.
	}
}
