# TODO

## mediasoup-client-aiortc

* Why is there a `Handler` class in `worker.py` and why does requests and notifications call `handler.xxx()` instead of directly doing the stuff? Do we really need such a `Handler` class and `handler` singleton?

* DataChannel.
  - No "error" event implemented in aiortc.
  - "message" events generated by aiortc are not wrapped into a `MessageEvent` but, instead, the "message" event is emitted with a `data` argument that may be a string or a binary. Take it into consideration.
  - We do not update `dc.bufferedAmount` in JS. We may notify its native value from py to JS for each sent message, received message, 'bufferedamountlow' event, etc. 
  - Let's figure out how to deal with binary messages for sending and receiving, we should encode them somehow to JSON serializable text, i.e. base64:

```python
>>> empty_bytes = bytes(4)
>>> type(empty_bytes).__name__
'bytes'

>>> foo = "hehe"
>>> type(foo).__name__
'str'
```

  - Let's figure out how to deal with `binaryType` stuff (aiortc does not implement it since it just makes sense in JS).
  - Need tests.
  - Eventually I got this (before fixing the "open" event stuff so it may never happen again):

```
terminal> roomClient._chatDataProducer.readyState
'open'


terminal> roomClient.sendChatMessage("CHAT")
  mediasoup-client:RoomClient sendChatMessage() [text:"CHAT] +12m
  mediasoup-client:DataProducer send() +12m
  mediasoup-client:aiortc:Channel notify() [event:datachannel.send] +12m
Promise { undefined }
terminal>   mediasoup-client:aiortc:Worker (stdout) Task exception was never retrieved +12m
  mediasoup-client:aiortc:Worker (stdout) future: <Task finished coro=<RTCSctpTransport._data_channel_flush() done, defined at /usr/local/lib/python3.7/site-packages/aiortc/rtcsctptransport.py:1604> exception=ConnectionError('Cannot send encrypted data, not connected')> +0ms
  mediasoup-client:aiortc:Worker (stdout) Traceback (most recent call last): +1ms
  mediasoup-client:aiortc:Worker (stdout)   File "/usr/local/lib/python3.7/site-packages/aiortc/rtcsctptransport.py", line 1642, in _data_channel_flush +0ms
  mediasoup-client:aiortc:Worker (stdout)     ordered=channel.ordered, +0ms
  mediasoup-client:aiortc:Worker (stdout)   File "/usr/local/lib/python3.7/site-packages/aiortc/rtcsctptransport.py", line 1314, in _send +0ms
  mediasoup-client:aiortc:Worker (stdout)     await self._transmit() +0ms
  mediasoup-client:aiortc:Worker (stdout)   File "/usr/local/lib/python3.7/site-packages/aiortc/rtcsctptransport.py", line 1535, in _transmit +0ms
  mediasoup-client:aiortc:Worker (stdout)     await self._send_chunk(chunk) +0ms
  mediasoup-client:aiortc:Worker (stdout)   File "/usr/local/lib/python3.7/site-packages/aiortc/rtcsctptransport.py", line 1326, in _send_chunk +0ms
  mediasoup-client:aiortc:Worker (stdout)     chunk, +0ms
  mediasoup-client:aiortc:Worker (stdout)   File "/usr/local/lib/python3.7/site-packages/aiortc/rtcdtlstransport.py", line 658, in _send_data +0ms
  mediasoup-client:aiortc:Worker (stdout)     raise ConnectionError("Cannot send encrypted data, not connected") +0ms
  mediasoup-client:aiortc:Worker (stdout) ConnectionError: Cannot send encrypted data, not connected +0ms
```


* Use `sourceType` for files and URLs.


## aiortc

Things that must be verified, asked or even reported in aiortc project.

* If `rtcConfiguration` is given without `iceServers` or with empty `iceServers: []`, it fails. This is a BUG in aiortc.
  - Reported: https://github.com/aiortc/aiortc/issues/266

* Must verify max number of SCTP streams (`OS` and `MIS`). For instance it's `OS: 1024, MIS: 1024` in Chrome (cannot renegotiate it later) and `OS: 16, MIS: 2048` in Firefox (which does allow later renegotiation).
  - In https://github.com/aiortc/aiortc/blob/master/src/aiortc/rtcsctptransport.py:
    `MAX_STREAMS = 65535`, and it seems to support renegotiation.

* Must report lack of `track.enabled = xxx` to pause sending RTP (or generate silence or black video with less bitrate).
  - Reported: https://github.com/aiortc/aiortc/issues/264
  - Store the legit track and replace the track `replaceTrack` with the base audio or video track.

* Does only emit 'open' for the first DataChannel.
  - Solved by checking the state after replying to DataChannel creation request and notifying about it if by that time 'readyState' is 'open'

* Does mandate MaxRetransmits. Providing MaxPacketLifeTime and not the former results in error.
